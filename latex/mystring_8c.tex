\section{mystring.c File Reference}
\label{mystring_8c}\index{mystring.c@{mystring.c}}
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include \char`\"{}mystring.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
char $\ast$ \bf{mystrdup} (const char $\ast$src)
\item 
char $\ast$ \bf{mystrndup} (const char $\ast$s, size\_\-t n)
\begin{CompactList}\small\item\em Deep copy the src string in a new block, leaves the original intact. \item\end{CompactList}\item 
size\_\-t \bf{mystrlen} (const char $\ast$s)
\begin{CompactList}\small\item\em Finds the length of the null terminated string. \item\end{CompactList}\item 
char $\ast$ \bf{mystrcpy} (char $\ast$dest, const char $\ast$src)
\begin{CompactList}\small\item\em Copy the string to a destination string. \item\end{CompactList}\item 
char $\ast$ \bf{mystrncpy} (char $\ast$dest, const char $\ast$src, size\_\-t n)
\begin{CompactList}\small\item\em Copies the string pointed to by src, including the terminating null byte to the buffer pointed to by dest, at most n bytes. \item\end{CompactList}\item 
char $\ast$ \bf{mystrcat} (char $\ast$dest, const char $\ast$src)
\begin{CompactList}\small\item\em Appends the src string to the dest string, overwriting terminating null byte at the end of dest, and adds a terminating null byte. \item\end{CompactList}\item 
char $\ast$ \bf{mystrncat} (char $\ast$dest, const char $\ast$src, size\_\-t n)
\begin{CompactList}\small\item\em Appends the src string to the dest string, overwriting terminating null byte at the end of dest, and adds a terminating null byte- however, this function uses at most n bytes from src. \item\end{CompactList}\end{CompactItemize}


\subsection{Function Documentation}
\index{mystring.c@{mystring.c}!mystrcat@{mystrcat}}
\index{mystrcat@{mystrcat}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrcat (char $\ast$ {\em dest}, const char $\ast$ {\em src})}\label{mystring_8c_ebc286ca79fc1f0b7ca5d05066cd79a7}


Appends the src string to the dest string, overwriting terminating null byte at the end of dest, and adds a terminating null byte. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dest}]String to be appended. \item[{\em src}]String to append to.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A concatenated string from src and dest. \end{Desc}
\index{mystring.c@{mystring.c}!mystrcpy@{mystrcpy}}
\index{mystrcpy@{mystrcpy}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrcpy (char $\ast$ {\em dest}, const char $\ast$ {\em src})}\label{mystring_8c_515b2c58f31e99a4564e463ffbf73e2f}


Copy the string to a destination string. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em $\ast$dest}]pointer to destination string. \item[{\em $\ast$src}]pointer to source string. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The destination string. \end{Desc}
\index{mystring.c@{mystring.c}!mystrdup@{mystrdup}}
\index{mystrdup@{mystrdup}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrdup (const char $\ast$ {\em src})}\label{mystring_8c_148a52c665d88f52fb4995338a319d3c}


Duplicates a C-style string. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em src}]Pointer to string to be copied \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to freshly-allocated string containing a duplicate of src or null if no memory is available \end{Desc}
\index{mystring.c@{mystring.c}!mystrlen@{mystrlen}}
\index{mystrlen@{mystrlen}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t mystrlen (const char $\ast$ {\em s})}\label{mystring_8c_a231246d7f6f97231aa18689cc2ea20a}


Finds the length of the null terminated string. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em s}]The string to determine length. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The length of the string. \end{Desc}
\index{mystring.c@{mystring.c}!mystrncat@{mystrncat}}
\index{mystrncat@{mystrncat}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrncat (char $\ast$ {\em dest}, const char $\ast$ {\em src}, size\_\-t {\em n})}\label{mystring_8c_36e5091b981e9da826d41e7977b8e507}


Appends the src string to the dest string, overwriting terminating null byte at the end of dest, and adds a terminating null byte- however, this function uses at most n bytes from src. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dest}]String to be appended. \item[{\em src}]String to append to. \item[{\em n}]Max number of bytes to append. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A concatenated string from src and dest, at a limit of n. \end{Desc}
\index{mystring.c@{mystring.c}!mystrncpy@{mystrncpy}}
\index{mystrncpy@{mystrncpy}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrncpy (char $\ast$ {\em dest}, const char $\ast$ {\em src}, size\_\-t {\em n})}\label{mystring_8c_86b7a78bb3914b2c6e6022b482c4a534}


Copies the string pointed to by src, including the terminating null byte to the buffer pointed to by dest, at most n bytes. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em dest}]String to copy to \item[{\em src}]String to be copied \item[{\em n}]Max number of bytes to cpy \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A pointer to the destination string dest \end{Desc}
\index{mystring.c@{mystring.c}!mystrndup@{mystrndup}}
\index{mystrndup@{mystrndup}!mystring.c@{mystring.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ mystrndup (const char $\ast$ {\em s}, size\_\-t {\em n})}\label{mystring_8c_9dc11eca5ee6b0e312610650bbe36e6d}


Deep copy the src string in a new block, leaves the original intact. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]Max number of bytes to duplicate \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Pointer to deep copied string containing a duplicate of src \end{Desc}
